//-----------------------------------------------------------------------------
// Entaro ChucK Developer!
// This is a chugin boilerplate, generated by chuginate!
//-----------------------------------------------------------------------------
// for more information on command-line options:
//      https://chuck.stanford.edu/doc/program/options.html
// for more information on chugins:
//      https://chuck.stanford.edu/extend/
//-----------------------------------------------------------------------------
// happy chucking & chugging!
//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------

// include chugin header
#include "chugin.h"

// general includes
#include <iostream>
#include <float.h>
#include <stdlib.h>
#include <limits.h>
#include <math.h>
#include "AmbiMath.h"

static int w_constant = 1;
static double g_pi = CK_ONE_PI;

// declaration of chugin constructor
CK_DLL_CTOR( ambimath_ctor );
// declaration of chugin desctructor
CK_DLL_DTOR( ambimath_dtor );

// example of getter/setter
CK_DLL_MFUN( ambimath_setParam );
CK_DLL_MFUN( ambimath_getParam );

// for chugins extending UGen, this is mono synthesis function for 1 sample
CK_DLL_TICK( ambimath_tick );

// this is a special offset reserved for chugin internal data
t_CKINT ambimath_data_offset = 0;

float degreeRad(float degree)
{
    return (g_pi / 180) * degree;
}

//-----------------------------------------------------------------------------
// class definition for internal chugin data
// (NOTE this isn't strictly necessary, but is one example of a recommended approach)
//-----------------------------------------------------------------------------
class AmbiMath
{
public:
    // constructor
    AmbiMath( t_CKFLOAT fs )
    {
        m_param = 0;
    }

    // for chugins extending UGen
    SAMPLE tick( SAMPLE in )
    {
        // default: this passes whatever input is patched into chugin
        return in;
    }

    // set parameter example
    t_CKFLOAT setParam( t_CKFLOAT p )
    {
        m_param = p;
        return p;
    }

    // get parameter example
    t_CKFLOAT getParam() { return m_param; }
    
private:
    // instance data
    t_CKFLOAT m_param;
};


//-----------------------------------------------------------------------------
// info function: ChucK calls this when loading/probing the chugin
// NOTE: please customize these info fields below; they will be used for
// chugins loading, probing, and package management and documentation
//-----------------------------------------------------------------------------
CK_DLL_INFO( AmbiMath )
{
    // the version string of this chugin, e.g., "v1.2.1"
    QUERY->setinfo( QUERY, CHUGIN_INFO_CHUGIN_VERSION, "v0.0.1 - 'Lanquidity'");
    // the author(s) of this chugin, e.g., "Alice Baker & Carl Donut"
    QUERY->setinfo( QUERY, CHUGIN_INFO_AUTHORS, "Everett M. Carpenter" );
    // text description of this chugin; what is it? what does it do? who is it for?
    QUERY->setinfo( QUERY, CHUGIN_INFO_DESCRIPTION, "AmbiMath calculates cartesian coordinates given an elevation angle and directional angle. As of v0.0.1 'Landquidity', coordinates up to the third order are available." );
    // (optional) URL of the homepage for this chugin
    QUERY->setinfo( QUERY, CHUGIN_INFO_URL, "" );
    // (optional) contact email
    QUERY->setinfo( QUERY, CHUGIN_INFO_EMAIL, "" );
}


//-----------------------------------------------------------------------------
// query function: ChucK calls this when loading the chugin
// modify this function to define this chugin's API and language extensions
//-----------------------------------------------------------------------------
CK_DLL_QUERY( AmbiMath )
{
    // generally, don't change this...
    QUERY->setname( QUERY, "AmbiMath" );

    // ------------------------------------------------------------------------
    // begin class definition(s); will be compiled, verified,
    // and added to the chuck host type system for use
    // ------------------------------------------------------------------------
    // NOTE to create a non-UGen class, change the second argument
    // to extend a different ChucK class (e.g., "Object")
    QUERY->begin_class( QUERY, "AmbiMath", "Object" );
    QUERY->doc_class(QUERY, "Math required for Ambisonics");

    // register default constructor
    QUERY->add_ctor( QUERY, ambimath_ctor );
    // NOTE constructors can be overloaded like any other functions,
    // each overloaded constructor begins with `QUERY->add_ctor()`
    // followed by a sequence of `QUERY->add_arg()`

    // register the destructor (probably no need to change)
    QUERY->add_dtor( QUERY, ambimath_dtor );

    // for UGens only: add tick function
    // NOTE a non-UGen class should remove or comment out this next line
    // QUERY->add_ugen_func( QUERY, ambimath_tick, NULL, 1, 1 );
    // NOTE: if this is to be a UGen with more than 1 channel,
    // e.g., a multichannel UGen -- will need to use add_ugen_funcf()
    // and declare a tickf function using CK_DLL_TICKF  
    // function definition

    // x coordinate
    QUERY->add_sfun(QUERY, x_Coordinate, "float", "x");
    QUERY->add_arg(QUERY, "float", "direction");
    QUERY->add_arg(QUERY, "float", "elevation");
    QUERY->doc_func(QUERY, "Computes cartesian X coordinate given elevation and direction angles");

    // y coodinate
    QUERY->add_sfun(QUERY, y_Coordinate, "float", "y");
    QUERY->add_arg(QUERY, "float", "direction");
    QUERY->add_arg(QUERY, "float", "elevation");
    QUERY->doc_func(QUERY, "Computes cartesian Y coordinate given elevation and direction angles");

    // z coordinate
    QUERY->add_sfun(QUERY, z_Coordinate, "float", "z");
    QUERY->add_arg(QUERY, "float", "direction");
    QUERY->add_arg(QUERY, "float", "elevation");
    QUERY->doc_func(QUERY, "Computes cartesian Z coordinate given elevation and direction angles");

    // r coordinate
    QUERY->add_sfun(QUERY, r_Coordinate, "float", "r");
    QUERY->add_arg(QUERY, "float", "direction");
    QUERY->add_arg(QUERY, "float", "elevation");
    QUERY->doc_func(QUERY, "Computes cartesian R coordinate given elevation and direction angles");

    // s coordinate
    QUERY->add_sfun(QUERY, s_Coordinate, "float", "s");
    QUERY->add_arg(QUERY, "float", "direction");
    QUERY->add_arg(QUERY, "float", "elevation");
    QUERY->doc_func(QUERY, "Computes cartesian S coordinate given elevation and direction angles");

    // t coordinate
    QUERY->add_sfun(QUERY, t_Coordinate, "float", "t");
    QUERY->add_arg(QUERY, "float", "direction");
    QUERY->add_arg(QUERY, "float", "elevation");
    QUERY->doc_func(QUERY, "Computes cartesian T coordinate given elevation and direction angles");

    // u coordinate
    QUERY->add_sfun(QUERY, u_Coordinate, "float", "u");
    QUERY->add_arg(QUERY, "float", "direction");
    QUERY->add_arg(QUERY, "float", "elevation");
    QUERY->doc_func(QUERY, "Computes cartesian U coordinate given elevation and direction angles");

    // v coordinate
    QUERY->add_sfun(QUERY, v_Coordinate, "float", "v");
    QUERY->add_arg(QUERY, "float", "direction");
    QUERY->add_arg(QUERY, "float", "elevation");
    QUERY->doc_func(QUERY, "Computes cartesian V coordinate given elevation and direction angles");

    // l coordinate
    QUERY->add_sfun(QUERY, l_Coordinate, "float", "l");
    QUERY->add_arg(QUERY, "float", "direction");
    QUERY->add_arg(QUERY, "float", "elevation");
    QUERY->doc_func(QUERY, "Computes cartesian L coordinate given elevation and direction angles");

    // m coordinate
    QUERY->add_sfun(QUERY, m_Coordinate, "float", "m");
    QUERY->add_arg(QUERY, "float", "direction");
    QUERY->add_arg(QUERY, "float", "elevation");
    QUERY->doc_func(QUERY, "Computes cartesian M coordinate given elevation and direction angles");

    // n coordinate
    QUERY->add_sfun(QUERY, n_Coordinate, "float", "n");
    QUERY->add_arg(QUERY, "float", "direction");
    QUERY->add_arg(QUERY, "float", "elevation");
    QUERY->doc_func(QUERY, "Computes cartesian N coordinate given elevation and direction angles");

    // o coordinate
    QUERY->add_sfun(QUERY, o_Coordinate, "float", "o");
    QUERY->add_arg(QUERY, "float", "direction");
    QUERY->add_arg(QUERY, "float", "elevation");
    QUERY->doc_func(QUERY, "Computes cartesian O coordinate given elevation and direction angles");

    // p coordinate
    QUERY->add_sfun(QUERY, p_Coordinate, "float", "p");
    QUERY->add_arg(QUERY, "float", "direction");
    QUERY->add_arg(QUERY, "float", "elevation");
    QUERY->doc_func(QUERY, "Computes cartesian P coordinate given elevation and direction angles");

    // q coordinate
    QUERY->add_sfun(QUERY, q_Coordinate, "float", "q");
    QUERY->add_arg(QUERY, "float", "direction");
    QUERY->add_arg(QUERY, "float", "elevation");
    QUERY->doc_func(QUERY, "Computes cartesian Q coordinate given elevation and direction angles");

    // k coordinate
    QUERY->add_sfun(QUERY, k_Coordinate, "float", "k");
    QUERY->add_arg(QUERY, "float", "direction");
    QUERY->add_arg(QUERY, "float", "elevation");
    QUERY->doc_func(QUERY, "Computes cartesian K coordinate given elevation and direction angles");

    /*
    // all coordinates
    QUERY->add_sfun(QUERY, coordinates, "float", "all");
    QUERY->add_arg(QUERY, "float", "direction");
    QUERY->add_arg(QUERY, "float", "elevation");
    QUERY->add_arg(QUERY, "array", "array");
    QUERY->add_arg(QUERY, "int", "order");
    QUERY->doc_func(QUERY, "Computes all coordinates of a given order and stores them in a provided array");
    */

    // create and set w constant
    QUERY->add_svar(QUERY, "float", "w", TRUE, &w_constant);
    QUERY->doc_var(QUERY, "W constant used in SN3D Ambisonics");
    
    // example of adding setter method
    QUERY->add_mfun( QUERY, ambimath_setParam, "float", "param" );
    // example of adding argument to the above method
    QUERY->add_arg( QUERY, "float", "arg" );

    // example of adding getter method
    QUERY->add_mfun( QUERY, ambimath_getParam, "float", "param" );
    
    // this reserves a variable in the ChucK internal class to store 
    // referene to the c++ class we defined above
    ambimath_data_offset = QUERY->add_mvar( QUERY, "int", "@am_data", false );

    // ------------------------------------------------------------------------
    // end the class definition
    // IMPORTANT: this MUST be called to each class definition!
    // ------------------------------------------------------------------------
    QUERY->end_class( QUERY );

    // wasn't that a breeze?
    return TRUE;
}


// implementation for the default constructor
CK_DLL_CTOR( ambimath_ctor )
{
    // get the offset where we'll store our internal c++ class pointer
    OBJ_MEMBER_INT( SELF, ambimath_data_offset ) = 0;
    
    // instantiate our internal c++ class representation
    AmbiMath * am_obj = new AmbiMath( API->vm->srate(VM) );
    
    // store the pointer in the ChucK object member
    OBJ_MEMBER_INT( SELF, ambimath_data_offset ) = (t_CKINT)am_obj;
}


// implementation for the destructor
CK_DLL_DTOR( ambimath_dtor )
{
    // get our c++ class pointer
    AmbiMath * am_obj = (AmbiMath *)OBJ_MEMBER_INT( SELF, ambimath_data_offset );
    // clean up (this macro tests for NULL, deletes, and zeros out the variable)
    CK_SAFE_DELETE( am_obj );
    // set the data field to 0
    OBJ_MEMBER_INT( SELF, ambimath_data_offset ) = 0;
}

// example implementation for setter
CK_DLL_MFUN( ambimath_setParam )
{
    // get our c++ class pointer
    AmbiMath * am_obj = (AmbiMath *)OBJ_MEMBER_INT( SELF, ambimath_data_offset );

    // get next argument
    // NOTE argument type must match what is specified above in CK_DLL_QUERY
    // NOTE this advances the ARGS pointer, so save in variable for re-use
    t_CKFLOAT arg1 = GET_NEXT_FLOAT( ARGS );
    
    // call setParam() and set the return value
    RETURN->v_float = am_obj->setParam( arg1 );
}

// example implementation for getter
CK_DLL_MFUN(ambimath_getParam)
{
    // get our c++ class pointer
    AmbiMath * am_obj = (AmbiMath *)OBJ_MEMBER_INT( SELF, ambimath_data_offset );

    // call getParam() and set the return value
    RETURN->v_float = am_obj->getParam();
}

CK_DLL_SFUN(x_Coordinate)
{
    float direction = GET_NEXT_FLOAT(ARGS);
    float elevation = GET_NEXT_FLOAT(ARGS);
    double x = (cos(degreeRad(direction)) * cos(degreeRad(elevation)));
    RETURN->v_float = x;
}

CK_DLL_SFUN(y_Coordinate)
{
    float direction = GET_NEXT_FLOAT(ARGS);
    float elevation = GET_NEXT_FLOAT(ARGS);
    double y = ((sin(degreeRad(direction))) * (cos(degreeRad(elevation))));
    RETURN->v_float = y;
}

CK_DLL_SFUN(z_Coordinate)
{
    float direction = GET_NEXT_FLOAT(ARGS);
    float elevation = GET_NEXT_FLOAT(ARGS);
    double z = (sin(degreeRad(elevation)));
    RETURN->v_float = z;
}

CK_DLL_SFUN(r_Coordinate)
{
    float direction = GET_NEXT_FLOAT(ARGS);
    float elevation = GET_NEXT_FLOAT(ARGS);
    double r = (0.5 * (3 * (pow((sin(degreeRad(elevation))), 2)) - 1));
    RETURN->v_float = r;
}

CK_DLL_SFUN(s_Coordinate)
{
    float direction = GET_NEXT_FLOAT(ARGS);
    float elevation = GET_NEXT_FLOAT(ARGS);
    double s = (0.8660254038 * (cos(degreeRad(direction))) * (sin((2 * degreeRad(elevation)))));
    RETURN->v_float = s;
}

CK_DLL_SFUN(t_Coordinate)
{
    float direction = GET_NEXT_FLOAT(ARGS);
    float elevation = GET_NEXT_FLOAT(ARGS);
    double t = (0.8660254038 * (sin(degreeRad(direction))) * (sin((2 * degreeRad(elevation)))));
    RETURN->v_float = t;
}

CK_DLL_SFUN(u_Coordinate)
{
    float direction = GET_NEXT_FLOAT(ARGS);
    float elevation = GET_NEXT_FLOAT(ARGS);
    double u = (0.8660254038 * cos(2 * degreeRad(direction)) * pow(cos(degreeRad(elevation)), 2));
    RETURN->v_float = u;
}

CK_DLL_SFUN(v_Coordinate)
{
    float direction = GET_NEXT_FLOAT(ARGS);
    float elevation = GET_NEXT_FLOAT(ARGS);
    double v = (0.8660254038 * sin(2 * degreeRad(direction)) * pow(cos(degreeRad(elevation)), 2));
    RETURN->v_float = v;
}

CK_DLL_SFUN(l_Coordinate)
{
    float direction = GET_NEXT_FLOAT(ARGS);
    float elevation = GET_NEXT_FLOAT(ARGS);
    double l = (0.6123724357 * cos(degreeRad(direction)) * cos(degreeRad(elevation)) * (5 * pow(sin(degreeRad(elevation)), 2) - 1));
    RETURN->v_float = l;
}

CK_DLL_SFUN(m_Coordinate)
{
    float direction = GET_NEXT_FLOAT(ARGS);
    float elevation = GET_NEXT_FLOAT(ARGS);
    double m = (0.6123724357 * sin(degreeRad(direction)) * cos(degreeRad(elevation)) * (5 * pow(sin(degreeRad(elevation)), 2) - 1));
    RETURN->v_float = m;
}

CK_DLL_SFUN(o_Coordinate)
{
    float direction = GET_NEXT_FLOAT(ARGS);
    float elevation = GET_NEXT_FLOAT(ARGS);
    double o = (1.936491673 * sin(2 * degreeRad(direction)) * sin(degreeRad(elevation)) * pow(cos(degreeRad(elevation)), 2));
    RETURN->v_float = o;
}

CK_DLL_SFUN(n_Coordinate)
{
    float direction = GET_NEXT_FLOAT(ARGS);
    float elevation = GET_NEXT_FLOAT(ARGS);
    double n = (1.936491673 * cos(2 * degreeRad(direction)) * sin(degreeRad(elevation)) * pow(cos(degreeRad(elevation)), 2));
    RETURN->v_float = n;
}

CK_DLL_SFUN(p_Coordinate)
{
    float direction = GET_NEXT_FLOAT(ARGS);
    float elevation = GET_NEXT_FLOAT(ARGS);
    double p = (0.790569415 * cos(3 * degreeRad(direction)) * pow(cos(degreeRad(elevation)), 3));
    RETURN->v_float = p;
}

CK_DLL_SFUN(q_Coordinate)
{
    float direction = GET_NEXT_FLOAT(ARGS);
    float elevation = GET_NEXT_FLOAT(ARGS);
    double q = (0.790569415 * sin(3 * degreeRad(direction)) * pow(cos(degreeRad(elevation)), 3));
    RETURN->v_float = q;
}

CK_DLL_SFUN(k_Coordinate)
{
    float direction = GET_NEXT_FLOAT(ARGS);
    float elevation = GET_NEXT_FLOAT(ARGS);
    double k = (0.5 * sin(degreeRad(elevation)) * (5 * pow(sin(degreeRad(elevation)), 2) - 3));
    RETURN->v_float = k;
}
